ADR-002 ‚Äî Wallet Authentication Flow (Phantom, Signature, JWT)
Status

Status

Proposed ‚Üí Accepted

Context

The system requires an authentication mechanism without users or passwords, based on cryptographic wallet ownership (Phantom / Solana).

The goal is not:

Web2-style authentication

Email/password login

Role-based authorization (not yet)

The goal is:

Prove cryptographic identity

Prevent impersonation

Prevent replay attacks

Maintain a session without requiring wallet signing on every request

Core Concepts
Cryptographic Identity

A wallet public key represents the base identity of the system.

‚ÄúWhoever controls the private key controls the identity.‚Äù

It does not represent:

a person

a persisted user

permissions or roles

It represents:

proof of private key ownership

Cryptographic Signature

A signature is mathematical proof that:

a private key signed

a specific message

without revealing the private key

It is not:

a blockchain transaction

a smart contract interaction

an on-chain operation

It is off-chain cryptography only.

Backend Challenge

A challenge is a message:

generated by the backend

unique and unpredictable

time-limited

It is used to:

prove login intent

prevent replay attacks

Replay Attack

A replay attack occurs when:

an attacker steals a valid signature

and reuses it to authenticate again

Example of an insecure flow:

Static message: "login"
Valid signature ‚Üí reusable forever ‚ùå


Secure solution:

Unique message + expiration ‚Üí single-use signature ‚úÖ

Decision

The system implements a challenge-based wallet authentication flow, with the session maintained using a JWT issued by the backend.

The wallet:

does not maintain sessions

only proves identity

High-Level Login Flow
[User]
   |
   | clicks "Login with Phantom"
   v
[Frontend]
   |
   | 1. GET /auth/challenge
   v
[Backend]
   |
   | generates unique challenge
   | stores nonce + expiration
   v
[Frontend]
   |
   | 2. wallet.signMessage(challenge)
   v
[Wallet (Phantom)]
   |
   | returns signature
   v
[Frontend]
   |
   | 3. POST /auth/login
   |    { publicKey, signature, challenge }
   v
[Backend]
   |
   | verifies signature
   | validates challenge
   | issues JWT
   v
[Frontend]
   |
   | stores JWT
   v
[Authenticated Session]

Detailed Flow (Responsibilities)
1Ô∏è‚É£ Login initiation

Frontend

User initiates login

No cryptographic action yet

2Ô∏è‚É£ Backend issues challenge

Backend

Generates a unique challenge

Example:

LOGIN::nonce=abc123::expires=1700000000


Properties:

random nonce

short expiration (e.g. 1‚Äì5 minutes)

single-use

The backend only trusts challenges it generated.

3Ô∏è‚É£ Wallet signs the challenge

Frontend + Phantom

Phantom signs the challenge

Uses the wallet private key

Returns a cryptographic signature

The private key never leaves the wallet.

4Ô∏è‚É£ Backend verifies identity (SignatureService)

Backend receives:

{
  publicKey,
  message: challenge,
  signature
}


SignatureService.verify():

verifies the signature matches the message

verifies the signature matches the publicKey

throws InvalidSignatureError on failure

returns verified identity on success

Result:

{
  signer: publicKey,
  messageHash
}

5Ô∏è‚É£ Challenge validation (anti-replay)

Backend checks that the challenge:

exists

is not expired

has not been used before

Then marks it as consumed.

This protects against:

replay attacks

stolen signatures

session reuse

6Ô∏è‚É£ JWT issuance (session)

Backend issues a JWT:

{
  "wallet": "ABC123",
  "iat": 1700000000,
  "exp": 1700003600
}


Meaning:

‚ÄúThe backend has verified this wallet identity recently.‚Äù

JWT does not encode:

roles

permissions

ownership

7Ô∏è‚É£ Authenticated session

Frontend:

stores the JWT

sends it with each request

Authorization: Bearer <jwt>


Backend:

validates JWT

extracts wallet identity

applies business rules

Error Handling
InvalidSignatureError

Thrown when:

the signature does not match the message

the signature does not match the publicKey

the signature is malformed or invalid

Protects against:

impersonation

forged signatures

incorrect key usage

ChallengeInvalidError (future)

Thrown when:

challenge is expired

challenge was already used

challenge does not exist

Protects against:

replay attacks

reused login attempts

Why JWT instead of signing every request?

Wallet signing:

requires user interaction

hurts UX

does not scale

JWT:

maintains session state

expires

is revocable

is backend-controlled

JWT does not replace cryptographic verification.
It represents a previously verified identity.

Roles & Authorization (Future)

Cryptographic identity is later used to:

assign roles

authorize actions

audit workflows

Future flow:

JWT ‚Üí identity ‚Üí role ‚Üí authorization ‚Üí action

Security Layers Summary

SignatureService ‚Äî proves cryptographic identity

Challenge ‚Äî prevents replay attacks

JWT ‚Äî maintains secure session

Roles ‚Äî authorize actions (future)

Blockchain ‚Äî enforces final state

Each layer is independent and composable.

Consequences
Positive

No passwords

No initial user database

Strong security model

Modern UX

Scalable architecture

Negative

Higher conceptual complexity

Requires explicit testing

Conclusion

Phantom-based login is not ‚Äújust signing something‚Äù.
It is a cryptographic identity protocol.

The backend:

defines challenges

verifies signatures

maintains sessions

The wallet:

proves private key ownership

This cryptographic identity becomes the foundation of the entire system.

Context

El sistema requiere un mecanismo de autenticaci√≥n sin usuarios ni contrase√±as, basado en posesi√≥n criptogr√°fica de una wallet (Phantom / Solana).

No se busca:

autenticaci√≥n Web2

login con email/password

autorizaci√≥n por roles (todav√≠a)

Se busca:

probar identidad criptogr√°fica

evitar suplantaci√≥n

evitar replay attacks

mantener sesi√≥n sin volver a firmar cada request

Core Concepts (terminolog√≠a clara)
Identidad criptogr√°fica

La wallet (publicKey) es la identidad base del sistema.

‚ÄúQuien controla la private key controla la identidad‚Äù

No representa:

persona

usuario

permisos

Representa:

posesi√≥n de clave privada

Firma criptogr√°fica (signature)

Una signature es una prueba matem√°tica de que:

una private key firm√≥

un mensaje espec√≠fico

sin revelar la private key

No es:

una transacci√≥n

un smart contract

algo on-chain

Es off-chain.

Challenge (backend challenge)

Un challenge es un mensaje:

generado por el backend

√∫nico

impredecible

con expiraci√≥n

Sirve para:

probar intenci√≥n de login

evitar replay attacks

Replay attack (ataque de repetici√≥n)

Un replay attack ocurre cuando:

un atacante roba una firma v√°lida

la reutiliza para autenticarse otra vez

Ejemplo inseguro:

Mensaje fijo: "login"
Firma v√°lida ‚Üí reutilizable para siempre ‚ùå


Soluci√≥n:

Mensaje √∫nico + expiraci√≥n ‚Üí firma de un solo uso ‚úÖ

Decision

El sistema implementa un login basado en firma de challenge, con sesi√≥n mantenida mediante JWT emitido por el backend.

La wallet no mantiene sesi√≥n.
La wallet solo prueba identidad.

Login Flow (alto nivel)
[Usuario]
   |
   | click "Login with Phantom"
   v
[Frontend]
   |
   | 1. GET /auth/challenge
   v
[Backend]
   |
   | genera challenge √∫nico
   | guarda nonce + expiraci√≥n
   v
[Frontend]
   |
   | 2. wallet.signMessage(challenge)
   v
[Wallet (Phantom)]
   |
   | devuelve signature
   v
[Frontend]
   |
   | 3. POST /auth/login
   |    { publicKey, signature, challenge }
   v
[Backend]
   |
   | verifica firma
   | valida challenge
   | emite JWT
   v
[Frontend]
   |
   | guarda JWT
   v
[Sesi√≥n autenticada]

Detailed Step-by-Step (con responsabilidades)
1Ô∏è‚É£ Inicio de login

Frontend

Usuario hace click ‚ÄúLogin‚Äù

No firma nada todav√≠a

2Ô∏è‚É£ Backend emite challenge

Backend

Genera un challenge √∫nico

Ejemplo conceptual:

LOGIN::nonce=abc123::expires=1700000000


Propiedades:

nonce aleatorio

expiraci√≥n corta (ej: 1‚Äì5 min)

solo v√°lido una vez

üìå El backend conf√≠a solo en challenges que √©l cre√≥.

3Ô∏è‚É£ Wallet firma el challenge

Frontend + Phantom

Phantom firma el challenge

Usa la private key

Devuelve una signature

üìå La private key nunca sale de la wallet.

4Ô∏è‚É£ Backend verifica identidad (SignatureService)

El backend recibe:

{
  publicKey,
  message: challenge,
  signature
}


El SignatureService.verify() hace:

Verifica que:

la signature corresponde al message

la signature corresponde a la publicKey

Si falla ‚Üí InvalidSignatureError

Si pasa ‚Üí identidad verificada

Resultado:

{
  signer: publicKey,
  messageHash
}

5Ô∏è‚É£ Validaci√≥n del challenge (anti-replay)

El backend:

verifica que el challenge:

existe

no expir√≥

no fue usado

lo marca como consumido

Si falla:

rechaza login

Esto protege contra:

replay attacks

firmas robadas

reuso de sesiones

6Ô∏è‚É£ Emisi√≥n de JWT (sesi√≥n)

El backend emite un JWT:

{
  "wallet": "ABC123",
  "iat": 1700000000,
  "exp": 1700003600
}


Este JWT significa:

‚ÄúYo, backend, verifiqu√© esta wallet recientemente‚Äù

No significa:

permisos

roles

ownership de datos

7Ô∏è‚É£ Sesi√≥n autenticada

El frontend:

guarda el JWT

lo env√≠a en cada request

Authorization: Bearer <jwt>


El backend:

valida JWT

recupera la identidad (wallet)

decide qu√© hacer con ella

Error Handling (seguridad expl√≠cita)
InvalidSignatureError

Se lanza cuando:

la firma no corresponde al message

la firma no corresponde a la publicKey

la firma es inv√°lida

Protege contra:

suplantaci√≥n

firmas falsas

claves incorrectas

ChallengeInvalidError (futuro)

Se lanza cuando:

challenge expir√≥

challenge ya fue usado

challenge no existe

Protege contra:

replay attacks

reuso de firmas

Why JWT and not wallet every time?

Firmar con wallet:

requiere interacci√≥n del usuario

rompe UX

no escala

JWT:

mantiene sesi√≥n

expira

es revocable

es backend-controlled

üìå JWT no reemplaza la firma
üìå JWT representa una identidad ya verificada

Roles & Authorization (futuro)

La identidad criptogr√°fica se usa luego para:

asignar roles (finance, logistics, etc.)

validar permisos

auditar acciones

Flujo futuro:

JWT ‚Üí identidad ‚Üí rol ‚Üí autorizaci√≥n ‚Üí acci√≥n

Security Summary

Capas de seguridad:

SignatureService

prueba identidad criptogr√°fica

Challenge

evita replay attacks

JWT

mantiene sesi√≥n segura

Roles

autorizan acciones

Blockchain

valida estado final

Cada capa es independiente.

Consequences
Positivas

No passwords

No user DB inicial

Alta seguridad

UX moderna

Arquitectura escalable

Negativas

Mayor complejidad conceptual

Requiere tests expl√≠citos

Conclusion

El login con Phantom no es solo ‚Äúfirmar algo‚Äù.
Es un protocolo de identidad.

El backend:

define el challenge

valida la firma

mantiene la sesi√≥n

La wallet:

prueba posesi√≥n de la clave privada

La identidad criptogr√°fica es la base de todo el sistema.
